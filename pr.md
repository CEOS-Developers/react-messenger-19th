> # 배포 링크
>
> [배포 링크](https://react-messenger-19th-seungwan-wg21.vercel.app/)

## 📌 구현 기능

1. 피그마에 나타난 화면 UI 구현 => `styled-components`의 `ThemeProvider`를 통해 디자인 시스템 구축
2. 기존의 **json** 파일에 나타난 데이터를 보여주거나 이미 데이터가 존재한다면 이를 보여주기
3. 사용자가 채팅을 입력하고, 기존의 데이터에 뒤이어 UI로 구현 => 채팅 입력 시, 채팅창의 최하단으로 포커스 이동
4. 사용자가 이미 보낸 상대방의 메시지를 더블 클릭하면 하트 UI가 생성되고, 다시 더블 클릭하면 사라짐
5. 채팅방 상단의 프로필을 클릭하면 상대방으로 사용자가 바뀜

## 🧠 느낀 점 및 시간 투자 부분

### 시간 투자 💪🏼

1. 절대 경로를 이용하기 위해 `tsconfig.json` 파일을 이용하려 했지만, CRA의 기본 동작상 이를 그냥 무시하기에 `webpack` 빌드 툴의 설정을 바꿔야 했습니다. 이를 `craco`(CRA configuration Overriding)JS의 설정을 하는데에 시간 소요가 다소 걸렸습니다.<br>
2. 기존의 state를 이용한 prop drilling이나 `contextAPI`를 사용해도 좋지만 recoilJS 전역 상태관리 라이브러리를 사용하니 쉬웠던 것 같습니다.<br>
3. 새로 고침을 해주어도 기존의 사항이 반영되도록 localStorage를 이용했습니다. 로컬 스토리지에 기존의 데이터가 없다면 json 파일의 데이터를 상태로 정하고 이를 로컬 스토리지에 반영하며, 기존의 데이터가 존재한다면 상태로 이용하는 분기적인 로직을 구현했습니다. 다만, 추후에 메시지의 추가나 더블 클릭을 통한 좋아요 하트 표시의 생성과 삭제 시에 객체가 `readOnly` 속성인 점을 유의해야 했던 것 같습니다. 이를 위해 스프레드 연산자를 사용하지 못하는 경우도 많았습니다. 스프레드 연산자를 사용하면 중첩된 속성이 다시 객체 혹은 배열이라면 `deepcopy`가 되지 않기 때문에 `JSON.parse(JSON.stringify({기존 객체}))`방식을 이용했습니다.<br>
4. 사용자가 input 박스에 focus 했을을 판단하기 위해 `isInputBoxFocused` 속성을 이용했습니다. 기존에 풀려있다가 focus되면 true로 만들어주는 경우, 아직 focus 안됐는데 제출 버튼을 클릭한 경우(이는 무시됨), focus 되었는데 메시지가 없는 경우(무시됨), focus 되었는데 제출 버튼을 클릭했지만 이것이 메시지를 담는 경우에 onBlur 때문에 발동되는 함수를 조기에 `return`시키고 다음의 onSubmit 트리거 함수에서 data 상태와 로컬스토리지를 업데이트 시킨 뒤 그 다음 `isInputBoxFocused` 속성을 `false`로 바꿔주는 로직을 작성했습니다.
5. 메시지를 추가하고 스크롤을 제일 아래로 내리는 것을 DOM 요소의 `scrollTop`과 `scrollHeight` 속성을 이용하여 구현하고자 했습니다. 하지만 이는 추가적인 메시지 DOM 요소가 생성되기 이전에 트리거 되므로 기존의 DOM 요소 높이만을 계산합니다. 따라서 이를 `messageData` 상태가 배뀌면 바로 트리거 되도록 `chatBody` 컴포넌트 내의 `useEffect` 훅을 이용하여 구현해주니 해결되었습니다. <br><br>

### 느낀 점 ❗️

1. 기존에 심미적으로 깔끔하고 이쁜 레이아웃을 만드는 것보다는 다른 방면으로 UX를 향상시키는 것에 관심이 많은 편이기에, 디자이너 분께서 UI 초안을 제시해주셔서 상당히 좋았던 것 같습니다. 또한 UI 컴포넌트마다 재사용될 수 있도록 분리해 놓으셔서 이를 활용해 재사용성을 높일 수 있었습니다.

2. 어떤 상태를 설정하고 이를 어떻게 활용할지 미리 설계해두고 들어가면 참 좋겠다는 생각, 이를 위해서는 UI 컴포넌트의 단위를 잘 설정해야 한다는 것을 알 수 있었습니다.

3. 타입스크립트를 사용하면 내가 에상하지 못하는 케이스를 시스템이 잡아줄 수 있다는 것을 알 수 있었습니다.

## ❓ Key Questions

- JavaScript를 사용할때에 비해 TypeScript를 사용할 때의 장점은 무엇인가요? <br>

> 타입스크립트를 사용하면 정적 타입 검사를 통해 에러를 런타임 이전에 방지할 수 있습니다.<br>

타입스크립트는 Javascript 언어의 superset으로서, tsc와 같은 컴파일러의 컴파일링을 통해 Javascript로 변환되어 실행됩니다. 타입 스크립트를 사용하면 `type alias`나 `interface`와 같은 개념을 통해 매개변수에 전달되는 인자의 타입을 강제할 수 있어 컴파일 시간에 오류를 잡아낼 수 있습니다. 이는 프로그래밍 작업 시에 vscode 단에서 오류를 미리 표시해주어 상당히 편리하다고 할 수 있습니다.<br>
특정 함수나 객체를 작성할 때 vscode 단에서 미리 매개변수나 속성들을 추천해주어 개발 생산성이 상당히 올라간다고 할 수 있습니다.

- 디자이너로부터 전달받은 피그마 링크 혹은, 피그마 캡처본 <br>

- 컴포넌트를 분리한 기준은 무엇인가요? <br>

크게 UI에서 고정이 되는 부분과, 유동적으로 바뀔 수 있는 부분에 대해서 생각을 많이 했던 것 같습니다. 화면에서 채팅의 개수가 늘어날 때마다 `chatBody`이 스크롤 되어야 함, 사용자가 `input box`에 focus 했을 때 왼쪽의 플러스 버튼이 사라지고, 다시 해제되었을 때에는 생성되는 것도 상태를 이용한 조건부 렌더링을 통해 UI를 구축했습니다. <br><br>
크게 `iphoneStatusBar`, `chatHeadNav`를 상단부에, 중간에 `chatBody`를, 아래에 `chatInput`과 `HomeIndicator`를 구성했고 마지막 `HomeIndicator` main 요소에 참조하여 항상 하단에 고정해주었습니다.

> 다양한 UI 컴포넌트들은 `components`, recoil을 통한 상태 생성은 `context`, css 설정 관련해서는 `styles`, ts를 위한 공통적인 타입 정의는 `type`, 여기저기에서 쓰일 간단한 함수들은 `utils` 디렉터리에 구분하여 만들어 주었습니다.

- 디자인 시스템을 적용하면서 느낀 점은 무엇인가요? <br>

디자인 시스템을 적용하며 느낀점은 바로 "재활용성"입니다. 디자이너 분께서 특정 컨셉을 활용하시기에, 중구 난방으로 튀는 디자인 원칙이 아닌 일관적인 UI 시스템은 사용자로 하여금 UX를 향상할 수 있습니다. 이를 `styled-components` 라이브러리의 시스템을 활용하니 손쉽게 사용할 수 있어 좋았습니다. <br>

다만, 스타일드 컴포넌트는 `css-in-js` 시스템이기 때문에 결국에는 Javascript 코드가 css 파일로 변환되어야함을 의미합니다. 이를 추후에 `nextJS`와 같은 풀스택 프레임워크와 함께 사용된다면 서버 사이드 렌더링이 진행될텐데 어떻게 활용할 수 있을지 궁금합니다.

- 디자이너와 소통하며 느낀점은 무엇인가요? <br>

원래 figma 툴의 사용법에 대해서 거의 무지한 수준이었습니다. 하지만 디자이너 분께서 작성해주신 피그마 툴의 요소 간의 거리 측정 기능, 이미지 파일로의 전환 기능 등에 대해서 소개 받을 수 있었고 이해가 잘 가지 않는 것에 대해서도 질문할 수 있었습니다. 또한 매번 개인 카톡으로 연락 드리기보다는 comment 기능을 활용하여 제가 원하는 질문을 남겨놓으면 디자이너 분께서 가능하실 때 보시고 답변해주셔서 유연하다고 생각해습니다.
<br>
