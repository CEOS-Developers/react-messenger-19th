# 🥳 배포 링크

https://react-messenger-19th-taupe.vercel.app/

# ⚙️ 구현 기능

<img width="760" alt="image" src="https://github.com/CEOS-Developers/react-messenger-19th/assets/101055312/b78e0d0b-f8d2-4a32-903e-3b8cd26ad5ea">

![화면 기록 2024-03-29 오후 9 20 44 (1)](https://github.com/CEOS-Developers/react-messenger-19th/assets/101055312/f5128e75-1798-4afd-b183-713668a26bb6)

## React Hooks 사용

1. **useState**: ChatBottom 컴포넌트에서 사용자가 입력한 메시지 값을 관리 등 컴포넌트의 상태를 관리하기 위해 사용했습니다.
2. **useEffect**: UI와 관련 없는 부수 효과를 수행하기 위해 사용했습니다. 예시로, ChattingRoom 컴포넌트가 마운트될 때 서버에서 메시지 목록을 불러오거나, 메시지 목록이 업데이트될 때마다 자동으로 스크롤 위치를 조정할 때 사용했습니다.
3. **useRef**: DOM 요소에 직접 접근하기 위해 사용되는 훅입니다. 새 메시지가 추가될 때마다 채팅 목록의 스크롤을 가장 아래로 이동시키기 위해 messagesEndRef를 사용했습니다.

- 작동 방식 : messagesEndRef는 채팅 목록 끝 참조 → useEffect 훅을 통해, 메시지가 추가될 때마다, current가 가리키는 DOM 요소(채팅 목록 끝)로 스크롤을 이동시킴

```typescript
const messagesEndRef = useRef<HTMLDivElement | null>(null);

//..
useEffect(() => {
	// 메시지가 추가될 때마다 스크롤을 하단으로 이동
	messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
}, [messages]);
```

# ✅ Key Questions

## JavaScript를 사용할때에 비해 TypeScript를 사용할 때의 장점은 무엇인가요?

1. 타입 체크를 통한 오류 예방

```typescript
interface Message {
	id: number;
	from: string;
	content: string;
	date: string;
}

interface ChatBodyProps {
	messages: Message[];
	currentUser: string;
	userImage: string;
}

const [messages, setMessages] = useState<Message[]>([]);
```

ChatBodyProps 인터페이스는 ChatBody 컴포넌트가 받아야 할 props의 구조와 타입을 명시적으로 정의해주기 때문에,
컴포넌트에 잘못된 타입의 props를 전달하거나 전달하지 않았을 경우, 컴파일 단계에서 바로 오류를 발견할 수 있습니다.

또한 메시지를 추가하는 함수 내에서 newMessage 객체를 생성할 때, Message 인터페이스에서 요구하는 속성을 빼먹거나 잘못된 타입을 사용하면 TypeScript 컴파일러가 즉시 오류를 표시하기 떄문에, 런타임 오류를 방지하고, 실수 가능성을 줄입니다.

2. 코드 자동 완성 및 리팩토링 용이
   컴포넌트에 어떤 props를 전달해야 하는지 쉽게 알 수 있고, 이는 개발 효율성을 높입니다.
   또한 특정 인터페이스의 구조를 변경해야 한다면, TypeScript를 사용하면 해당 인터페이스를 사용하는 모든 곳을 찾아 수정해야 함을 알 수 있기 때문에, 더욱 안전하고 빠른 리팩토링이 가능합니다.

3. 코드 의도와 구조 명확화
   인터페이스를 통해 코드의 의도와 구조를 다른 개발자에게 명확히 전달할 수 있어 코드의 가독성이 향상됩니다.

## 디자이너로부터 전달받은 피그마 링크 혹은, 피그마 캡처본

<img width="741" alt="스크린샷 2024-03-29 오후 7 16 01" src="https://github.com/CEOS-Developers/react-messenger-19th/assets/101055312/02e7d0b3-0898-457b-b5da-2720a632cf28">

## 컴포넌트를 분리한 기준은 무엇인가요?

1. 각 컴포넌트를 UI 영역별 & 기능별로 분리했습니다.
   단일 책임 원칙에 따라 한 가지 기능만 수행하도록 설계했습니다.

- **ChatHead**: 채팅방의 상단에 위치한 사용자 프로필을 표시합니다. 사용자 이름과 이미지를 포함합니다.
- **ChatBody**: 채팅방에서의 대화 내용을 표시합니다. 메시지마다 시간과 날짜, 사용자 프로필 이미지를 표시할 수 있도록 구현했습니다.
- **ChatBottom**: 메시지 입력창과 전송 버튼을 포함합니다. 사용자 입력을 받고, 'Enter' 키나 전송 버튼 클릭 시 메시지를 전송하는 기능을 구현했습니다.

2. 또한, 버튼, 입력 필드같이, 사용자 이벤트에 따라, 특정 기능을 하고, 자주 사용되는 UI들도 재사용이 용이하게 별도의 컴포넌트로 분리했습니다.

## 디자인 시스템을 적용하면서 느낀 점은 무엇인가요?

디자인 시스템을 적용함으로써 UI의 일관성을 유지할 수 있었던 것 같습니다.
또한, 개발 과정에서도 확실히 편리함을 느꼈습니다.
우선, 디자인 시스템을 통해 개발자와 디자이너 간의 커뮤니케이션이 명확해졌고, 일관된 디자인 언어를 공유할 수 있었습니다.
또한, UX/UI적인 고민을 덜어 개발에만 집중할 수 있어 좋았던 것 같습니다.
디자인 시스템을 활용하면서 서비스를 만들 때는 정말 여러 UI 요소들이 있다는 것을 느꼈습니다. 이러한 UI 요소들은 모두 교체 가능성이 있으므로, 서비스의 규모가 커질수록, 나중에 UI 요소들을 교체하기 편하게 컴포넌트를 분리하고 가독성 있는 코드를 짜는 것이 중요하다는 깨달음을 얻었습니다.

## 디자이너와 소통하며 느낀점은 무엇인가요?

피그마에 만들어주신 UI를 가지고 개발하면서, 혼자 개발하고, UI까지 만들 때와는 퀄리티가 다른 결과물이 나온 것 같다는 생각이 듭니다.
특히, 메시지를 입력할 때는 아이콘이 보내기 버튼이고, 입력하지 않을 때는 마이크 아이콘인 것은, 너무 당연한 UX이나, 일상 속에서는 신경쓰지 않고 지나쳤었는데, 피그마에서 UI 하나하나를 가져다 개발하면서, 정말 이는 사용자 친화적인 것 같다는 생각이 들었습니다.

# 💡 느낀 점

처음에는 json에 데이터를 저장한다는게, 새로 입력된 대화 내역도 업데이트해야 한다고 생각해, 어떻게 구현할지 감이 잡히지 않아,
우선은 로컬 스토리지와 useEffect를 사용하여 대화 내역을 저장하고 관리하는 것을 구현했습니다.
json에 더미 데이터를 저장해야하는 것을 이어서 계속 고민해보다가 백엔드도 구현해야 하는건가?...라는 생각을 하며 json-server를 통해 json 데이터를 업데이트하는 법을 계속해서 시도했었습니다.
그런데, 초기 데이터만 json 파일에 저장하고, 이를 불러오는 것이란 걸 알고, 안심하며 초기 메시지 로드 하는 부분을 로컬 스토리지에서, -> json 파일에서 json 객체를 가져오는 것으로 수정했습니다.
이를 통해, json에 새로 입력된 대화 내역도 업데이트해야 하는 것도 구현해보고 싶다는 생각이 너무 커져서, 중간고사 이후에 이 부분을 구현하는게 기대가 됩니다.
